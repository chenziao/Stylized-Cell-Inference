09/24/2021 02:41:00 PM INFO: Reading notebook InferenceModel.ipynb
09/24/2021 02:41:01 PM INFO: Running cell:
import os, sys
sys.path.append(os.path.split(sys.path[0])[0])

#Dependencies
import h5py
import math
import matplotlib.pyplot as plt
import numpy as np
import pickle
from sbi.inference import SNPE, prepare_for_sbi, simulate_for_sbi
import sbi.analysis as analysis
from sbi.utils.get_nn_models import posterior_nn  # For SNLE: likelihood_nn(). For SNRE: classifier_nn()
from scipy import signal, stats as spstats
import scipy.io
import torch
import torch.nn as nn
import torch.nn.functional as F

#Project Imports
import config.params as params
import config.paths as paths
from stylized_module.base.passive_model_soma_injection import run_pm_simulation
from stylized_module.base.active_model_synapse_input import run_am_simulation
from stylized_module.models.SummaryStats2D import Stats, cat_output
from utils.metrics.corrcoef import corrcoef, max_corrcoef
from utils.plotting.plot_results import plot_LFP_traces,plot_LFP_heatmap
from utils.spike_window import first_pk_tr, get_spike_window
from utils.transform.distribution_transformation import norm2unif, range2logn, norm2logn, logds_norm2unif, logds_norm2logn

Warning: no DISPLAY environment variable.
--No graphics will be displayed.
09/24/2021 02:41:02 PM INFO: Cell returned
09/24/2021 02:41:02 PM INFO: Running cell:
rng = np.random.default_rng(123412)

def passive_model(param,whole_trace=False):
    #Replace theta with random number
    theta = [rng.uniform(low=params.IM_THETA_BOUNDS[0], high=params.IM_THETA_BOUNDS[1])]
    sim.set_loc_param(torch.cat((torch.zeros(1),param[:2], torch.tensor(theta), param[2:4])))
    scalVal = 1 #10 ** param[5]
    sim.set_scale(scalVal)
    sim.set_geo_param(param[4:])
    sim.create_cells()
    sim.run()
    lfp = sim.get_lfp().T
    filtered_lfp = signal.lfilter(filt_b,filt_a,lfp,axis=0) # filter along row of the lfp 2d-array, if each row is a channel
    if not whole_trace:
        start,end = get_spike_window(filtered_lfp,win_size=params.PM_WINDOW_SIZE,align_at=fst_idx)
        filtered_lfp = filtered_lfp[start:end,:]
    return filtered_lfp

def active_model(param,whole_trace=False):
#     biophys = [param[0],-1,-1,param[1],-1,param[2],-1]
#     sim.set_biophys(biophys)
    
    #Replace alpha with random number
    alpha = rng.uniform(low=params.IM_ALPHA_BOUNDS[0], high=params.IM_ALPHA_BOUNDS[1])
    d = norm2unif(param[1], params.IM_PARAMETER_BOUNDS[1][0], params.IM_PARAMETER_BOUNDS[1][1])
    theta = norm2unif(param[2], params.IM_PARAMETER_BOUNDS[2][0], params.IM_PARAMETER_BOUNDS[2][1])
    x = d * np.sin(theta)
    z = d * np.cos(theta)
    
    numpy_list = np.array([
        x, #x
        norm2unif(param[0], params.IM_PARAMETER_BOUNDS[0][0], params.IM_PARAMETER_BOUNDS[0][1]), #y
        z, #z
        alpha, #alpha
        norm2unif(param[3], params.IM_PARAMETER_BOUNDS[3][0], params.IM_PARAMETER_BOUNDS[3][1]), #h
        norm2unif(param[4], params.IM_PARAMETER_BOUNDS[4][0], params.IM_PARAMETER_BOUNDS[4][1]) #phi
    ])
    
    sim.set_loc_param(torch.from_numpy(numpy_list))
    
    geo_list = np.zeros(6)
    geo_list[0] = norm2unif(param[5], params.IM_PARAMETER_BOUNDS[5][0], params.IM_PARAMETER_BOUNDS[5][1])
    for i in range(6,11):
        if i == 6:
            m,s=range2logn(params.IM_PARAMETER_BOUNDS[i][0], params.IM_PARAMETER_BOUNDS[i][1], n_sigma=3)
        else:
            m,s=range2logn(params.IM_PARAMETER_BOUNDS[i][0], params.IM_PARAMETER_BOUNDS[i][1])
        geo_list[i-5] = norm2logn(param[i], m, s)

#     m1,s1=range2logn(params.IM_PARAMETER_BOUNDS[5][0], params.IM_PARAMETER_BOUNDS[5][1], n_sigma=3)
#     l_t  =norm2unif(param[5], params.IM_PARAMETER_BOUNDS[5][0], params.IM_PARAMETER_BOUNDS[5][1])
#     m2,s2=range2logn(params.IM_PARAMETER_BOUNDS[6][0], params.IM_PARAMETER_BOUNDS[6][1], n_sigma=3)
#     m3,s3=range2logn(params.IM_PARAMETER_BOUNDS[7][0], params.IM_PARAMETER_BOUNDS[7][1])
#     m4,s4=range2logn(params.IM_PARAMETER_BOUNDS[8][0], params.IM_PARAMETER_BOUNDS[8][1])
#     m5,s5=range2logn(params.IM_PARAMETER_BOUNDS[9][0], params.IM_PARAMETER_BOUNDS[9][1])
#     m6,s6=range2logn(params.IM_PARAMETER_BOUNDS[10][0], params.IM_PARAMETER_BOUNDS[10][1])

#     numpy_list = np.array([
#         l_t,                       #l_t
#         norm2logn(param[6],m2,s2), #r_s
#         norm2logn(param[7],m3,s3), #r_t
#         norm2logn(param[8],m4,s4), #r_d
#         norm2logn(param[9],m5,s5), #r_tu, shouldn't be inferred?
#         norm2logn(param[10],m6,s6) #l_d
#     ])

    sim.set_geo_param(torch.from_numpy(geo_list))

    scalVal = 1 #10 ** param[5]
    sim.set_scale(scalVal)
    
    sim.set_gmax(params.GT_GMAX)
#     scalVal = 10 ** param[4]
    sim.set_scale(scalVal)
    sim.create_cells()
    sim.run()
    lfp = sim.get_lfp().T
    filtered_lfp = signal.lfilter(filt_b,filt_a,lfp,axis=0) # filter along row of the lfp 2d-array, if each row is a channel
    if not whole_trace:
        start,end = get_spike_window(filtered_lfp,win_size=params.AM_WINDOW_SIZE,align_at=fst_idx)
        filtered_lfp = filtered_lfp[start:end,:]
    return filtered_lfp

# def Stats(lfp):
#     """
#     Calculates summary statistics
#     results = model(params)
#     """
#     lfp = np.asarray(lfp)
    
#     avg = np.mean(lfp,axis=0) # average voltage of each channel
# #     stdDev = np.std(lfp,axis=0) # stDev of the voltage of each channel
#     tT = np.argmin(lfp,axis=0)
#     tP = np.argmax(lfp,axis=0)
#     Troughs = np.take_along_axis(lfp,np.expand_dims(tT,axis=0),axis=0)
#     Peaks = np.take_along_axis(lfp,np.expand_dims(tP,axis=0),axis=0)
#     relT = tP-tT
#     stats_list = [avg,Troughs,Peaks,relT]
    
#     def statscalc(stats):
#         stats = stats.ravel()
#         mean = np.mean(stats)
#         std = np.std(stats)
#         m = np.argmin(stats)
#         min_pos = params.IM_Y_DISTANCE[m]
#         min_val = stats[m]
#         M = np.argmax(stats)
#         max_pos = params.IM_Y_DISTANCE[M] 
#         max_val = stats[M]
#         All = np.array([mean,std,min_pos,min_val,max_pos,max_val])
#         return All
    
#     allStats = np.concatenate([statscalc(x) for x in stats_list])
#     return allStats

# def cat_output(lfp):
#     output = np.concatenate((lfp.ravel(),Stats(lfp)))
#     return torch.from_numpy(output)

def simulation(sim_params):
    lfp = passive_model(sim_params) if params.ACTIVE_CELL is False else active_model(sim_params)
    return cat_output(lfp)

09/24/2021 02:41:03 PM INFO: Cell returned
09/24/2021 02:41:03 PM INFO: Running cell:
filt_b,filt_a = signal.butter(params.IM_BUTTERWORTH_ORDER,
                              params.IM_CRITICAL_FREQUENCY,
                              params.IM_BANDFILTER_TYPE,
                              fs=params.IM_FILTER_SAMPLING_RATE)

sim, window_size, x0_trace, t0 = run_pm_simulation() if params.ACTIVE_CELL is False else run_am_simulation()

fst_idx = first_pk_tr(x0_trace)

09/24/2021 02:41:03 PM INFO: Cell returned
09/24/2021 02:41:03 PM INFO: Running cell:
simulator, prior = prepare_for_sbi(simulation, params.IM_PRIOR_DISTRIBUTION)
x_o = cat_output(x0_trace)
print(x_o.shape)

09/24/2021 02:41:04 PM INFO: Cell returned
09/24/2021 02:41:04 PM INFO: Running cell:
# instantiate the neural density estimator
density_estimator_build_fun = posterior_nn(model=params.IM_POSTERIOR_MODEL_ESTIMATOR,
                                           embedding_net=params.IM_EMBEDDED_NETWORK,
                                           hidden_features=params.IM_POSTERIOR_MODEL_HIDDEN_LAYERS)

inference = SNPE(prior=prior,density_estimator=density_estimator_build_fun,show_progress_bars=True)

09/24/2021 02:41:04 PM INFO: Cell returned
09/24/2021 02:41:04 PM INFO: Running cell:
posteriors = []
proposal = prior

for i in range(params.IM_NUMBER_OF_ROUNDS):
    theta, x = simulate_for_sbi(simulator,proposal,num_simulations=params.IM_NUMBER_OF_SIMULATIONS)
     # In `SNLE` and `SNRE`, you should not pass the `proposal` to `.append_simulations()`
#     density_estimator = inference.append_simulations(np.squeeze(theta), np.squeeze(x), proposal=proposal).train()
    density_estimator = inference.append_simulations(np.squeeze(theta), x, proposal=proposal).train()
    posterior = inference.build_posterior(density_estimator, sample_with="mcmc")
    
    with open(paths.POSTERIOR_SAVE + str(i) + "_post.pkl", "wb") as handle:
        pickle.dump(posterior, handle)
        
    with open(paths.POSTERIOR_SAVE + str(i) + "_de.pkl", "wb") as handle:
        pickle.dump(density_estimator, handle)
        
    posteriors.append(posterior)
    proposal = posterior.set_default_x(x_o)
    
inference._summary_writer = None
inference._build_neural_net = None
with open(paths.INFERENCER_SAVE + str(i) + ".pkl", "wb") as handle:
    pickle.dump(inference, handle)

# with open(paths.POSTERIOR_SAVE + "1_post.pkl", "rb") as handle:
#     posterior = pickle.load(handle)

09/25/2021 02:27:57 AM INFO: Cell returned
Traceback (most recent call last):
  File "/home/mjc6r9/envs/stylized-cell/bin/runipy", line 8, in <module>
    sys.exit(main())
  File "/home/mjc6r9/envs/stylized-cell/lib64/python3.8/site-packages/runipy/main.py", line 158, in main
    nb_runner.run_notebook(skip_exceptions=args.skip_exceptions)
  File "/home/mjc6r9/envs/stylized-cell/lib64/python3.8/site-packages/runipy/notebook_runner.py", line 232, in run_notebook
    self.run_cell(cell)
  File "/home/mjc6r9/envs/stylized-cell/lib64/python3.8/site-packages/runipy/notebook_runner.py", line 207, in run_cell
    raise NotImplementedError(
NotImplementedError: unhandled iopub message: comm_open
[IPKernelApp] WARNING | Parent appears to have exited, shutting down.
